import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { fieldsParser } from './fieldsParser';

var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
  return string.substring(0, 1).toUpperCase() + string.substring(1);
};
/**
 * Resolver to use when using graphqlParser output with graphql-anywhere.
 *
 * @param {string} fieldName
 * @param {object} rootValue
 */


export var contentfulResolver = function contentfulResolver(fieldName, rootValue) {
  return rootValue && rootValue.hasOwnProperty(fieldName) ? rootValue[fieldName] : null;
};
/**
 * Parse Contentful Rest API response into a format that can be queried via
 * GraphQL.
 *
 * @param {string} operationName
 * @param {object} data
 * @param {object} props
 * @return {object}
 */

export function graphqlParser(rootKey, data, definitionMap, props) {
  var _ref2;

  if (props === void 0) {
    props = {
      include: 10
    };
  }

  /**
   * Clean the cloned object and map back refernces that were stripped via fieldsParser.
   *
   * @param {object} clone -
   * @param {object} ref -
   * @return {object}
   */
  function cleanClone(clone, ref) {
    var _clone$sys, _clone$sys2;

    if (!clone) return clone; // Capitalize entry __typename

    if (clone.hasOwnProperty('__typename') && clone.__typename) {
      clone.__typename = capitalizeFirstLetter(clone.__typename);
    } // Set sys __typename


    if (ref && ref.sys) {
      clone.sys = _objectSpread(_objectSpread({}, ref.sys), {}, {
        __typename: 'Sys'
      });
    } else if (ref.id) {
      clone.sys = {
        id: ref.id,
        __typename: 'Sys'
      };
    } // Map dates to GraphQL equivalents


    if (clone !== null && clone !== void 0 && (_clone$sys = clone.sys) !== null && _clone$sys !== void 0 && _clone$sys.createdAt) {
      clone.sys.firstPublishedAt = clone.sys.createdAt;
      delete clone.sys.createdAt;
    }

    if (clone !== null && clone !== void 0 && (_clone$sys2 = clone.sys) !== null && _clone$sys2 !== void 0 && _clone$sys2.updatedAt) {
      clone.sys.publishedAt = clone.sys.updatedAt;
      delete clone.sys.updatedAt;
    } // Clean-up sys properties applied to parsed entry via fieldsParser


    if (clone.id) {
      delete clone.id;
    }

    if (clone.createdAt) {
      if (!clone.sys.firstPublishedAt) {
        clone.sys.firstPublishedAt = clone.createdAt;
      }

      delete clone.createdAt;
    }

    if (clone.updatedAt) {
      if (!clone.sys.publishedAt) {
        clone.sys.publishedAt = clone.updatedAt;
      }

      delete clone.updatedAt;
    }

    return clone;
  }
  /**
   * Apply definitions defined in query to confirm that the resulting object
   * adheres to the shape expected by the query.
   *
   * @param {object} target -
   * @param {object} definitionMap -
   * @return {object}
   */


  function applyDefinitions(target, typename, definitionMap) {
    if (!target || !definitionMap) return target;
    var targetClone = Object.assign({}, target || {});
    Object.keys(definitionMap).forEach(function (definition) {
      if (!targetClone.hasOwnProperty(definition)) {
        if (definition.endsWith('Collection')) {
          var collectionField = definition.replace('Collection', '');
          var existingCollection = targetClone.hasOwnProperty(collectionField) && targetClone[collectionField];

          if (existingCollection) {
            targetClone[definition] = parseCollection(existingCollection, "" + typename + capitalizeFirstLetter(definition), definitionMap[definition]);
            delete targetClone[collectionField];
          } else {
            targetClone[definition] = parseCollection([], "" + typename + capitalizeFirstLetter(definition), definitionMap[definition]);
          }
        } else if (definition.startsWith('...') && targetClone.__typename && targetClone.__typename === definition.replace('...', '')) {
          Object.assign(targetClone, applyDefinitions(targetClone, typename, definitionMap[definition]));
        } else {
          targetClone[definition] = null;
        }
      }
    });
    return targetClone;
  }
  /**
   * Structure Contentful Asset instance into the shape supported via GraphQL.
   *
   * @param {object} object -
   * @return {object}
   */


  function parseAsset(object) {
    var _clone$file, _clone$file2, _clone$file3, _clone$file3$details, _clone$file4, _clone$file4$details, _clone$file4$details$, _clone$file5, _clone$file5$details, _clone$file5$details$, _clone$file6, _clone$file6$details, _clone$file6$details$, _clone$file7, _clone$file7$details, _clone$file7$details$, _clone$file8;

    var clone = Object.assign({}, object);
    clone.__typename = 'Asset';
    clone.url = clone === null || clone === void 0 ? void 0 : (_clone$file = clone.file) === null || _clone$file === void 0 ? void 0 : _clone$file.url;
    clone.contentType = clone === null || clone === void 0 ? void 0 : (_clone$file2 = clone.file) === null || _clone$file2 === void 0 ? void 0 : _clone$file2.contentType;
    clone.size = clone === null || clone === void 0 ? void 0 : (_clone$file3 = clone.file) === null || _clone$file3 === void 0 ? void 0 : (_clone$file3$details = _clone$file3.details) === null || _clone$file3$details === void 0 ? void 0 : _clone$file3$details.size;
    clone.width = (clone === null || clone === void 0 ? void 0 : (_clone$file4 = clone.file) === null || _clone$file4 === void 0 ? void 0 : (_clone$file4$details = _clone$file4.details) === null || _clone$file4$details === void 0 ? void 0 : (_clone$file4$details$ = _clone$file4$details.image) === null || _clone$file4$details$ === void 0 ? void 0 : _clone$file4$details$.width) || (clone === null || clone === void 0 ? void 0 : (_clone$file5 = clone.file) === null || _clone$file5 === void 0 ? void 0 : (_clone$file5$details = _clone$file5.details) === null || _clone$file5$details === void 0 ? void 0 : (_clone$file5$details$ = _clone$file5$details.video) === null || _clone$file5$details$ === void 0 ? void 0 : _clone$file5$details$.width);
    clone.height = (clone === null || clone === void 0 ? void 0 : (_clone$file6 = clone.file) === null || _clone$file6 === void 0 ? void 0 : (_clone$file6$details = _clone$file6.details) === null || _clone$file6$details === void 0 ? void 0 : (_clone$file6$details$ = _clone$file6$details.image) === null || _clone$file6$details$ === void 0 ? void 0 : _clone$file6$details$.height) || (clone === null || clone === void 0 ? void 0 : (_clone$file7 = clone.file) === null || _clone$file7 === void 0 ? void 0 : (_clone$file7$details = _clone$file7.details) === null || _clone$file7$details === void 0 ? void 0 : (_clone$file7$details$ = _clone$file7$details.video) === null || _clone$file7$details$ === void 0 ? void 0 : _clone$file7$details$.height);
    clone.fileName = clone === null || clone === void 0 ? void 0 : (_clone$file8 = clone.file) === null || _clone$file8 === void 0 ? void 0 : _clone$file8.fileName;

    if (!clone.url.startsWith('https:')) {
      clone.url = "https:" + clone.url;
    }

    delete clone.file;
    return clone;
  }
  /**
   * Parse a Contentful Entry instance
   *
   * @param {object} object -
   * @param {object} definitionMap -
   * @param {number} depth -
   * @return {object}
   */


  function parseEntry(object, typename, definitionMap, depth) {
    var _cleanedClone$sys;

    if (depth === void 0) {
      depth = 0;
    }

    if (!object) return null;

    if (depth >= props.include) {
      return object;
    }

    var objectClone = Object.assign({}, object.hasOwnProperty('sys') && object.hasOwnProperty('fields') ? fieldsParser(object, props, {
      parseArrays: false,
      parseRefs: false
    }) : object); // Parse all references and reference collections

    Object.keys(objectClone).forEach(function (key) {
      var field = objectClone[key];

      if (Array.isArray(field)) {
        var referenceArray = false;
        field.filter(function (item) {
          return !!item;
        }).forEach(function (item) {
          if (item.hasOwnProperty('sys') && item.hasOwnProperty('fields') || item.hasOwnProperty('__typename')) {
            referenceArray = true;
          }
        });

        if (referenceArray) {
          // Convert reference array into GraphQL
          var collectionKey = key + "Collection";
          objectClone[collectionKey] = parseCollection(field, "" + typename + capitalizeFirstLetter(collectionKey), definitionMap === null || definitionMap === void 0 ? void 0 : definitionMap[collectionKey], depth + 1); // Delete old flat array field

          delete objectClone[key];
        } else {
          objectClone[key] = field.map(function (item, index) {
            return cleanClone(item, object && object.fields && object.fields[key][index]);
          }).filter(function (item) {
            return !!item;
          });
        }
      } else if (field && typeof field === 'object' && (field.hasOwnProperty('__typename') || field.hasOwnProperty('sys') && field.hasOwnProperty('fields'))) {
        // Parse single entry references
        objectClone[key] = parseEntry(field, typename, definitionMap === null || definitionMap === void 0 ? void 0 : definitionMap[key], depth + 1);
      } else if (field && field.nodeType && field.nodeType === 'document') {
        objectClone[key] = {
          json: field
        };
      } else {
        objectClone[key] = field;
      }
    }); // Clean fields applied by fieldsParser and map sys object to item

    var cleanedClone = cleanClone(objectClone, object);
    var assetClone = (cleanedClone === null || cleanedClone === void 0 ? void 0 : (_cleanedClone$sys = cleanedClone.sys) === null || _cleanedClone$sys === void 0 ? void 0 : _cleanedClone$sys.type) === 'Asset' ? parseAsset(cleanedClone) : cleanedClone; // Make sure all queried fields are available on the response, even if not included in the Rest response

    var definedClone = applyDefinitions(assetClone, assetClone.__typename || typename, definitionMap); // Return GraphQL-ready object

    return definedClone;
  }
  /**
   * Parse a Contentful Entry collection
   *
   * @param {array} items -
   * @param {object} definitionMap -
   * @param {number} depth -
   * @return {object}
   */


  function parseCollection(items, typename, definitionMap, depth) {
    if (items === void 0) {
      items = [];
    }

    if (depth === void 0) {
      depth = 0;
    }

    // @todo Add `skip` to response object - Ryan
    // @todo Add `limit` to response object - Ryan
    return {
      __typename: typename,
      total: (items && Array.isArray(items) ? items : []).length,
      items: (items && Array.isArray(items) ? items : []).map(function (item) {
        return parseEntry(item, typename, definitionMap === null || definitionMap === void 0 ? void 0 : definitionMap.items, depth);
      }).filter(function (item) {
        return !!item;
      })
    };
  } // Parse collection queries


  if (data !== null && data !== void 0 && data.items) {
    var _ref;

    return _ref = {}, _ref[rootKey] = parseCollection(data.items, capitalizeFirstLetter(rootKey), definitionMap === null || definitionMap === void 0 ? void 0 : definitionMap[rootKey]), _ref;
  } // Parse single entry queries


  return _ref2 = {}, _ref2[rootKey] = _objectSpread({
    __typename: capitalizeFirstLetter(rootKey)
  }, parseEntry(data, capitalizeFirstLetter(rootKey), definitionMap === null || definitionMap === void 0 ? void 0 : definitionMap[rootKey])), _ref2;
}