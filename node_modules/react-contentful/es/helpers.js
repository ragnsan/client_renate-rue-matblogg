import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import warning from 'warning';
/**
 * Generate string to use as a cache key based on query props.
 * 
 * @param {*} props 
 * @return string
 */

export var generateCacheKey = function generateCacheKey(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      contentful = _props.contentful,
      contentType = _props.contentType,
      id = _props.id,
      include = _props.include,
      locale = _props.locale,
      query = _props.query;
  var contextLocale = contentful && contentful.locale;
  var requestLocale = locale || contextLocale;

  if (id) {
    return JSON.stringify({
      id: id,
      options: _objectSpread({
        locale: requestLocale,
        include: include
      }, query)
    });
  }

  return JSON.stringify(_objectSpread({
    content_type: contentType,
    locale: requestLocale,
    include: include
  }, query));
};
/**
 * Check the Contentful Client cache to see if results exists for generated cache key.
 * 
 * @param {*} props 
 * @return Object
 */

export var checkCache = function checkCache(props) {
  if (props === void 0) {
    props = {};
  }

  var _props2 = props,
      contentful = _props2.contentful,
      parser = _props2.parser;

  if (!contentful) {
    return null;
  }

  if (!contentful.client) {
    return null;
  }

  var cacheKey = generateCacheKey(props);
  var cache = contentful.client.checkCache(cacheKey);
  return cache ? parser(cache, props) : null;
};
/**
 * Validate that the props passed contain all required props for request.
 * 
 * @param {*} props 
 * @return Promise<boolean>
 */

export var validateRequestRequirements = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(props) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (props === void 0) {
              props = {};
            }

            return _context.abrupt("return", new Promise(function (resolve, reject) {
              var _props3 = props,
                  id = _props3.id,
                  contentType = _props3.contentType,
                  contentful = _props3.contentful,
                  include = _props3.include,
                  locale = _props3.locale,
                  parser = _props3.parser,
                  query = _props3.query; // Check for contentful context

              warning(contentful, 'No contentful context passed to <Query />');

              if (!contentful) {
                return reject('No contentful context passed to <Query />');
              }

              var client = contentful.client,
                  contextLocale = contentful.locale; // Check to make sure a client is available

              warning(client, 'ContentfulClient not available via context on <Query />');

              if (!client) {
                return reject('ContentfulClient not available via context on <Query />');
              }

              var hasQuery = !!(id || contentType || query === {}); // Check to make sure queryable props have been set

              warning(hasQuery, 'Query props not set on <Query />');

              if (!hasQuery) {
                return reject('Query props not set on <Query />');
              }

              return resolve(true);
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function validateRequestRequirements(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Fetch Contentful data.
 * 
 * @param {*} props 
 * @return Promise
 */

var _fetchData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (props === void 0) {
              props = {};
            }

            if (!props.skip) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt("return", Promise.resolve(null));

          case 3:
            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              var _props4 = props,
                  contentful = _props4.contentful,
                  contentType = _props4.contentType,
                  id = _props4.id,
                  include = _props4.include,
                  locale = _props4.locale,
                  query = _props4.query;
              validateRequestRequirements(props).then(function () {
                var client = contentful.client,
                    contextLocale = contentful.locale,
                    renderPromises = contentful.renderPromises;
                var requestLocale = locale || contextLocale;
                var request = id ? client.getEntry(id, _objectSpread({
                  locale: requestLocale,
                  include: include
                }, query)) : client.getEntries(_objectSpread({
                  'content_type': contentType,
                  locale: requestLocale,
                  include: include
                }, query));

                if (renderPromises) {
                  renderPromises.registerSSRObservable({
                    fetchData: function fetchData() {
                      return _fetchData(props);
                    },
                    props: props
                  }, request);
                }

                return request;
              }).then(resolve)["catch"](reject);
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function fetchData(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

export { _fetchData as fetchData };